#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\begin_preamble
\usepackage{wrapfig}
 \setlength{\intextsep}{0cm plus1cm minus1cm}
\newcommand{\menuitem}[1]{\textbf{\emph{#1}}}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language american
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 0
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 3in
\end_inset


\end_layout

\begin_layout Standard
\align center

\size giant
microHOPE
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/microhope-with-2x16lcd.jpg
	lyxscale 40
	width 9cm

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\align center

\size large
User's Manual 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\align center

\size largest
Micro-controllers
\begin_inset Newline newline
\end_inset

for
\begin_inset Newline newline
\end_inset

Hobby Projects and Education
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\align center
Ajith Kumar B P
\begin_inset Newline newline
\end_inset

ajith@iuac.res.in
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\align center
Inter-University Accelerator Centre 
\begin_inset Newline newline
\end_inset

(A Research Centre of UGC)
\begin_inset Newline newline
\end_inset

New Delhi 110 067
\begin_inset Newline newline
\end_inset

http://expeyes.in
\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
Most of computer systems in use today are embedded in other machinery, such
 as automobiles, telephones, appliances, and peripherals for computer systems.
 Most of them need minimal processing and memory requirements and can be
 implemented using micro-controllers (uC).
 A micro-controller is a small computer on a single integrated circuit consistin
g of a CPU combined with program and data memory, peripherals like analog
 to digital converters, timer/counters, serial communication ports and general
 purpose Input/Output ports.
 Intel 8051, Atmel AVR, PIC etc.
 are popular micro controllers available in the market.
 To design the microHOPE hardware, we have chosen ATmega32 micro-controller
 from Atmel, after considering the hardware resources available on it and
 the software support of GNU C compiler.
\end_layout

\begin_layout Subsubsection*
Why microHOPE ?
\end_layout

\begin_layout Standard
Many people who write programs that run on a PC find it difficult to get
 started on coding for a microcontroller, mainly due to two reasons: (1)
 Programming a uC require some knowledge about the target hardware.
 (2) Transferring the program to the target device generally require some
 special hardware and software.
 There are plenty of micro-controller development kits in the market, but
 most of them focus on the usage of their kit rather than the details of
 the the micro-controller.
 Programming the I/O pins of a development board using the library functions
 provided may be acceptable to get something done quickly, but our method
 is to directly deal with the the micro-controller, without hiding the uC
 details from the user.
 
\end_layout

\begin_layout Standard
A simple Graphical User Interface is provided to Edit, Compile and upload
 the program.
 We start by programming the Input/Output ports of Atmega32, which require
 some basic knowledge of binary number system, C language with its bit manipulat
ion operators.
 After that we will proceed to the programming of the peripherals like ADC,
 Timer/Counter etc.
 Since they are more complex, we will start with a software library, in
 the form of C source files, that can be included in your program
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We are very much aware of the drawback of this method.
 When you include a file all the functions in that will get added to your
 executable, increasing its size.
 Once the code is working, copy the necessary functions to your source file,
 instead of including the whole file, to get rid of this difficulty.
\end_layout

\end_inset

.
 Once you learn how to write code peripherals, using their control/data
 registers, there is no need to use these functions.
\end_layout

\begin_layout Standard
Since microHOPE comes with a bootloader pre-installed inside the program
 memory of Atmega32, you can upload code using the USB interface with a
 single click, from the GUI provided.
 At the same time, executing the compile and upload programs from a text
 terminal are also explained.
 For compiling the C program we use the 
\series bold
avr-gcc
\series default
 compiler and 
\series bold
avrdude
\series default
 for uploading it to the target.
 
\end_layout

\begin_layout Section
The Hardware
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/mh-block.png
	width 12cm

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
(a)MicroHOPE Block diagram.
\begin_inset CommandInset label
LatexCommand label
name "fig:MicroHOPE-Block-diagram."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A block diagram of microHOPE hardware is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MicroHOPE-Block-diagram."

\end_inset

.
 Programs can be uploaded from the PC through the USB port, using the pre-loaded
 boot loader code on the uC.
 To load a new program, the PC asserts the DTR signal of FT232, that resets
 ATmega32.
 On reset, the boot loader code will start to receive the new code from
 PC.
 After loading the new code, control is transferred to it.
 
\end_layout

\begin_layout Standard
Atmega32 has 32 Input/Output pins, organized as 4 ports, each 8 bit wide.
 The IC is available in DIP package, that can be socket mounted.
 The ATmega32 has 32 kB of Flash memory, 512 bytes EEPROM and 2 kB Static
 RAM.
 Three Timer/Counters, a serial programmable USART, a byte oriented Two-wire
 Serial Interface, an 8-channel 10-bit ADC and an SPI serial port are some
 of the peripheral devices on the chip.
\end_layout

\begin_layout Standard
The processor on the microHOPE board runs at 8MHz, using the external crystal.
 All the I/O pins, except the UART Rx/Tx pins, are available to the user
 on the four I/O connectors.
 An LED is connected to Bit 0 of Port B, for quick testing of the board.
 A reset button is also provided.
 The 5V USB power is connected to both VCC and AVCC inputs.
 A jumper is provided to disable the reset option from the PC.
 This is required when the final product is used for communicating to a
 PC.
\end_layout

\begin_layout Standard
An alphanumeric LCD display is available as an accessory to microHOPE, to
 help the program development.
 It can be connected to the PORTC socket and C functions are provided to
 access the display.
 
\end_layout

\begin_layout Section
The MicroHOPE Software
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/microhopeIDE.png
	lyxscale 50
	width 12cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
MicroHOPE User Interface
\begin_inset CommandInset label
LatexCommand label
name "fig:MicroHOPE-User-Interface"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
An Integrated Development Environment (IDE) is available for writing, compiling
 and uploading programs.
 It is available in .deb format, microhope-2.0.0.deb.
 To install it, under Debian/Ubuntu, open a Terminal and follow the steps
 given below:
\end_layout

\begin_layout LyX-Code
$ sudo -s
\end_layout

\begin_layout LyX-Code
# apt-get install gdebi
\end_layout

\begin_layout LyX-Code
# gdebi microhope-2.0.0.deb
\end_layout

\begin_layout Standard
After installing the package, drag the directory 
\series bold
/etc/skel/microhope
\series default
 to your home directory.
 The program can be started by choosing Science->microHOPE from the Applications
 menu.
 A screen shot of the microhope IDE is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MicroHOPE-User-Interface"

\end_inset

.
 By default it looks for files inside the microhope subdirectory inside
 your home directory.
 The IDE provides a menu to load/save files, compile and upload the program.
 
\end_layout

\begin_layout Standard
All the examples given in this document will appear inside the directory
 named 'microhope'.
 All files starting with 
\series bold
mh-
\series default
 are the files containing library functions to access the various peripherals
 of Atmega32.
 To make the source code visible to the user, they are not compiled as a
 library file.
 Do not modify the files starting with 
\series bold
mh-
\series default
.
 
\end_layout

\begin_layout Standard
You can select any of the example programs, compile and upload them using
 the menu.
 Correct all the compile errors before doing Upload.
 On GNU/Linux systems, the device file created for microHOPE hardware should
 be '/dev/ttyUSB0'.
 
\end_layout

\begin_layout Subsection
Compilation and Upload, without the IDE
\begin_inset CommandInset label
LatexCommand label
name "sub:Details-of-compilation"

\end_inset


\end_layout

\begin_layout Standard
Even though the IDE does the job, it is a good idea to learn about the programs
 used behind the seen, to compile and upload the code.
 
\series bold
Those who like to use only the IDE may skip this section
\series default
.
 The software packages used are:
\end_layout

\begin_layout Itemize
avr-gcc : To compile the C program, also require the C library avr-libc
\end_layout

\begin_layout Itemize
avr-objcopy : To generate the HEX file
\end_layout

\begin_layout Itemize
avrdude : To upload the Hex file
\end_layout

\begin_layout Standard
These packages are available under GNU/Linux.
 For Debian/Ubuntu distributions they can be installed from the repository
 using the commands:
\end_layout

\begin_layout LyX-Code
# apt-get install avr-libc
\end_layout

\begin_layout LyX-Code
# apt-get install avrdude
\end_layout

\begin_layout LyX-Code
# chmod u+s /usr/bin/avrdude
\end_layout

\begin_layout Standard
Installing avr-libc, automatically installs gcc-avr and other required packages.
 The last command will enable non-root users to use avrdude.
 The installed programs can be invoked from the command line.
 Use a text editor to create your source program, for example 
\series bold
blink.c
\series default
, and compile it using:
\end_layout

\begin_layout LyX-Code
$ avr-gcc  -Wall -O2 -mmcu=atmega32 -o blink blink.c
\end_layout

\begin_layout Standard
We have asked the compiler to print all the warnings, optimize to level
 2, generate code for atmega32.
 The executable output stored in blink and input taken from blink.c.
 The executable file is converted into Intel Hex format using the following
 command:
\end_layout

\begin_layout LyX-Code
$ avr-objcopy -j .text -j .data -O ihex blink blink.hex
\end_layout

\begin_layout Standard
The Hex file is now ready for upload.
 This can be done using the command:
\end_layout

\begin_layout LyX-Code
$ avrdude -b 19200 -P /dev/ttyUSB0 -pm32 -c stk500v1 -U flash:w:blink.hex
\end_layout

\begin_layout Standard
We have specified a baudrate of 19200, the output device is /dev/ttyUSB0,
 m32 processor and the transfer protocol stk500v1.
\end_layout

\begin_layout Subsubsection
Some batch files
\end_layout

\begin_layout Standard
Since a lot of command line arguments are required to specify the compiler,
 linker and loader options, it is convenient to put them in small batch
 files or shell scripts.
 These files can be found inside the 
\series bold
microhope
\series default
 directory, once the package is installed.
 The compilation of C code and generation of Intel Hex format file for uploading
 is done by 
\series bold
compile-mega32.sh
\series default
, listed below.
 
\end_layout

\begin_layout Quote

\family typewriter
avr-gcc  -Wall -O2 -mmcu=atmega32 -Wl,-Map,$1.map -o $1 $1.c 
\end_layout

\begin_layout Quote

\family typewriter
avr-objcopy -j .text -j .data -O ihex $1 $1.hex 
\end_layout

\begin_layout Quote

\family typewriter
avr-objdump -S $1 > $1.lst
\family default
 
\end_layout

\begin_layout Standard
For example, to compile a program named 'hello.c', it should be invoked from
 the command line as;
\end_layout

\begin_layout LyX-Code
$./compile-mega32.sh hello
\end_layout

\begin_layout Standard
The .c extension should not be specified.
 The script also generates the linker MAP file and a listing file, that
 may be used for examining the generated output.
\end_layout

\begin_layout Standard
Under GNU/Linux, microhope on the USB port will appear as file '/dev/ttyUSB0'
 and program uploading is done by 
\series bold
mh-upload.sh
\series default
, listed below
\end_layout

\begin_layout LyX-Code
avrdude -b 19200 -P /dev/ttyUSB0 -pm32 -c stk500v1 -U flash:w:$1.hex 
\end_layout

\begin_layout Standard
To upload hello.hex, use the command
\end_layout

\begin_layout LyX-Code
$./mh-upload hello
\end_layout

\begin_layout Subsection
Using under Raspberry Pi
\end_layout

\begin_layout Standard
The required packages are available on Raspberry Pi.
 Install and use as explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Details-of-compilation"

\end_inset


\end_layout

\begin_layout Subsection
Using under MS Windows
\end_layout

\begin_layout Standard
For Windows, you can download 
\series bold
winavr
\series default
 package from sourceforge.net and install it.
 Also download install avrdude for windows.
 You also need to download and install the drivers for FTDI232, the USB
 to Serial converter IC.
\end_layout

\begin_layout Standard
Use a text editor like notepad to edit the source program and save it with
 a .c extension.
 The commands for compilation and uploading are:
\end_layout

\begin_layout LyX-Code
C:
\backslash
> avr32-gcc  -Wall -O2 -mmcu=atmega32 -o blink blink.c
\end_layout

\begin_layout LyX-Code
C:
\backslash
> avr32-objcopy -j .text -j .data -O ihex blink blink.hex
\end_layout

\begin_layout LyX-Code
C:
\backslash
> avrdude -b 19200 -P COMxx -pm32 -c stk500v1 -U flash:w:blink.hex
\end_layout

\begin_layout Standard
Where COMxx is the virtual com port number assigned by Windows.
 
\end_layout

\begin_layout Standard
We have found it very difficult to get it going under Windows, due to the
 arbitrary naming of COM ports and reliability issues in the hardware communicat
ion.
\end_layout

\begin_layout Chapter
Getting Started
\end_layout

\begin_layout Standard
After installing the Debian package, you must have copied the directory
 /etc/skel/microhope to you home directory.
 Start the microHOPE IDE from the menu Applications->Science.
 Choosing File->Open from the menubar will display all the C files inside
 the 
\series bold
microhope
\series default
 directory.
 You can open any of the examples (except the filenames starting with mh-)
 , compile and upload it by clicking on the menubar.
 We will start by programming the Digital Input/Output ports of Atmega32,
 and them proceed to the peripheral devices
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
For complete details of Atmega32 refer to http://www.atmel.in/Images/doc2503.pdf
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The avr-gcc compiler allows us to program the control/data registers and
 their individual bits using the same names given in the Atmega32 manual.
 The registers are accessed just like normal variables, the statement PORTB
 = 15 , writes the number 15 to Port B.
 The individual pins are referred using names like PA0, means BIT 0 of PORTA.
 
\end_layout

\begin_layout Section
Testing the Hardware
\end_layout

\begin_layout Standard
Connect MicroHOPE hardware to a USB port and start the microHOPE IDE from
 the menu Applications->Science.
 The program will display the status of the hardware detected, it should
 appear as '/dev/ttyUSB0' in most cases.
 If you get an error message, reconnect the hardware and restart the program.
\end_layout

\begin_layout Standard
Using File->Open from the menubar, load 
\series bold
blink.c
\series default
 from the 
\series bold
microhope
\series default
 directory.
 Compile and Upload the program by clicking on the menu labels.
 It should give a message 'Upload Completed'.
 If not, check the USB connections first.
 If problem persists, try pressing and releasing the microHOPE Reset button
 at the same time when you click on Upload.
 
\end_layout

\begin_layout Standard
Once the program is uploaded, the LED connected to PB0 should blink at 1
 Hz rate.
 
\series bold
\bar under
If not, press the reset button on the board.
\end_layout

\begin_layout Section
Input/Output ports of Atmega32
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/avr-block.png
	width 8cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Atmega32 Pinout
\begin_inset CommandInset label
LatexCommand label
name "fig:Atmega32-Pinout"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The pinout diagram of Atmega32 is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Atmega32-Pinout"

\end_inset

.
 There are 32 pins organized as four ports named A, B, C and D, each 8 bit
 wide.
 Each pin can be configured as an input or output.
 The data direction and transfer are done by writing to the registers DDRX,
 PORTX and PINX (where X stands for A, B, C or D).
\end_layout

\begin_layout Itemize
DDRX : Every pin of an I/O port can be configured as Input or Output using
 the Data Direction registers DDRX.
 To configure a pin as output, set the corresponding bit in DDRX, and clear
 it to make the corresponding pin as input.
 For example, DDRA = 1 will configure BIT 0 of Port A (PA0) as output, and
 all other pins as input.
\end_layout

\begin_layout Itemize
PORTX : For pins that are configured as ouput, assigning a value to PORTX
 will set that data on them.
 For example PORTA = 1 will make PA0 high, that can be measured on the pin
 number 40 of the IC.
 
\end_layout

\begin_layout Itemize
PINX : For the pins configured as inputs, PINX will read the status of the
 external voltage level connected to the pins.
 For pins that are configured as outputs, PINX will return the data written
 to PORTX.
\end_layout

\begin_layout Standard
If the pins configured as inputs are left unconnected, there could be unwanted
 level changes due to electrical noise, this can be prevented by enabling
 the internal pull-up resistor.
 For pins that are configured as inputs, setting/clearing the bits in PORTX
 will enable/disable the corresponding internal pullup resistor.
 
\end_layout

\begin_layout Standard
The operations described above can be understood easily with some examples.
 For a quick test, MicroHOPE hardware has an LED connected to PB0, with
 a series resistor for current limiting.
\end_layout

\begin_layout Subsection
Reading and Writing Ports
\end_layout

\begin_layout Standard
The program 
\series bold
copy.c
\series default
 reads the voltage level at PA0 (Pin 0 of Port A) and sets the same on PB0,
 where we have the LED.
 We will enable the internal pullup resistor on PA0 so that and it will
 go LOW only when it is connected to ground using a piece of wire.
\end_layout

\begin_layout LyX-Code

\size small
#include <avr/io.h>   // Include file for I/O operations
\end_layout

\begin_layout LyX-Code

\size small
int main (void)
\end_layout

\begin_layout LyX-Code

\size small
{
\end_layout

\begin_layout LyX-Code

\size small
DDRA = 0;             // Port A as Input
\end_layout

\begin_layout LyX-Code
PORTA = 1;          // Enable pullup on PA0
\end_layout

\begin_layout LyX-Code

\size small
DDRB = 1;             // Configure PB0 as output  
\end_layout

\begin_layout LyX-Code

\size small
for(;;)
\end_layout

\begin_layout LyX-Code

\size small
     PORTB = PINA;   // Read Port A and write it to Port B
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
To test this example, open 
\series bold
copy.c
\series default
 from the File menu of microHOPE IDE, Click on Compile and then Upload from
 the menubar The LED on PB0 should start glowing after uploading the program.
 LED will be off when you connect PA0 to ground.
 You may rewrite the program so that the LED may be controlled by some other
 bit configured as input.
 
\end_layout

\begin_layout Standard
The simple program given above has certain drawbacks.
 It changes PORTB as a whole instead of acting on PB0 alone.
 Suppose we have something else connected to the other pins of Port B, they
 also will be affected by the action 
\begin_inset Formula $PORTB=PINA$
\end_inset

.
 To avoid such problems, we should manipulate individual bits.
 The include file 
\series bold
mh-digital.c
\series default
 contains macros for setting and clearing bits by specifying their position.
\end_layout

\begin_layout Subsection
Bit manipulation macros
\end_layout

\begin_layout Standard
These macros can be used on variables, defined in the program, and also
 on registers like DDRX, PORTX etc.
\end_layout

\begin_layout Subsubsection*
BITVAL(bit position)
\end_layout

\begin_layout Standard
The value of bit position could be 0 to 7 in the case of 8 bit integers
 and 0 to 15 for 16 bit integers.
 This macro returns (1 << bit position).
 For example BITVAL(3), will give 8, that is binary 1000, obtained by left
 shifting of 1 thrice.
\end_layout

\begin_layout Subsubsection*
SETBIT(variable, bit position)
\end_layout

\begin_layout Standard
This macro SETS the specified bit in the given variable, without affecting
 the other bits.
 For example SETBIT(DDRB, 7), will make the last bit of DDRB high.
\end_layout

\begin_layout Subsubsection*
CLRBIT(variable, bit position)
\end_layout

\begin_layout Standard
This macro clears the specified bit of the given variable.
 For example CLRBIT(val, 0), clears the least significant bit of 'val',
 that is an integer type variable.
\end_layout

\begin_layout Subsubsection*
GETBIT(variable, bit position)
\end_layout

\begin_layout Standard
This macro returns the specified bit if the specified bit of the variable
 is 1, else it returns zero.
 For example: if x = 3, GETBIT(x, 1) will return 2 and GETBIT(x,3) will
 return zero.
\end_layout

\begin_layout Standard
Let us rewrite the previous program as 
\series bold
copy2.c
\series default
, using these macros as:
\end_layout

\begin_layout LyX-Code

\size small
#include <avr/io.h>
\end_layout

\begin_layout LyX-Code

\size small
  int main (void)
\end_layout

\begin_layout LyX-Code

\size small
  {
\end_layout

\begin_layout LyX-Code

\size small
  uint8_t  val;
\end_layout

\begin_layout LyX-Code

\size small
  DDRA = 0;             // Port A as Input
\end_layout

\begin_layout LyX-Code
  PORTA = 1;          // Enable pullup on PORTA, bit 0
\end_layout

\begin_layout LyX-Code

\size small
  DDRB = 1;             // Pin 0 of Port B as output
\end_layout

\begin_layout LyX-Code

\size small
  for(;;)
\end_layout

\begin_deeper
\begin_layout LyX-Code
{
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
     val = GETBIT(PORTA, 0);
\end_layout

\begin_deeper
\begin_layout LyX-Code
if (val != 0)
\end_layout

\begin_layout LyX-Code
   SETBIT(PORTB, 0);
\end_layout

\begin_layout LyX-Code
else
\end_layout

\begin_deeper
\begin_layout LyX-Code
CLRBIT(PORTB, 0);
\end_layout

\end_deeper
\begin_layout LyX-Code
}
\end_layout

\end_deeper
\begin_layout LyX-Code

\size small
  }
\end_layout

\begin_layout Standard
The same can be done, without using the bit manipulation macros, as shown
 in 
\series bold
copy3.c
\end_layout

\begin_layout LyX-Code

\size small
#include <avr/io.h>   // Include file for I/O operations
\end_layout

\begin_layout LyX-Code

\size small
int main (void)
\end_layout

\begin_layout LyX-Code

\size small
{
\end_layout

\begin_layout LyX-Code

\size small
uint8_t  val;         // 8 bit unsigned word
\end_layout

\begin_layout LyX-Code

\size small
DDRA = 0;             // Port A as Input
\end_layout

\begin_layout LyX-Code
PORTA = 1;          // Enable pullup on PA0
\end_layout

\begin_layout LyX-Code

\size small
DDRB = 1;             // Configure PB0 as output  
\end_layout

\begin_layout LyX-Code

\size small
for(;;)
\end_layout

\begin_layout LyX-Code
   if(PINA & 1)        // If PA0 is set
\end_layout

\begin_layout LyX-Code
       PORTB |= 1;     // Set PB0, by ORing with 00000001b
\end_layout

\begin_layout LyX-Code
   else                // otherwise clear PB0
\end_layout

\begin_layout LyX-Code
       PORTB &= ~1;    // by ANDing with 11111110b (~00000001b)
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
The code fragment shown above uses the Bitwise AND, OR and NOT operators.
\end_layout

\begin_layout Subsection
Blinking LED
\end_layout

\begin_layout Standard
Making pin PB0 HIGH and LOW in a closed loop result in the blinking of the
 LED conencted to it.
 We need to slow down the rate of blinking so that it can be perceived by
 our eyes.
 This can be done by making the processor wait for a while between writing
 to PORTB.
 There are some delay functions provided for this.
 The file 
\series bold
mh-utils.c
\series default
 contains the following functions:
\end_layout

\begin_layout Subsubsection*
delay_100us(int n)
\end_layout

\begin_layout Standard
This function will make the CPU idle for n x100 microseconds.
 For example to insert a 200 microsecond delay, call delay_100us(2)
\end_layout

\begin_layout Subsubsection*
delay_ms(int n)
\end_layout

\begin_layout Standard
This function will make the CPU idle for n milliseconds.
 For example to insert a 500 millisecond delay, call delay_ms(500)
\end_layout

\begin_layout Standard
The program blink.c lis listed below:
\end_layout

\begin_layout LyX-Code

\size small
#include 
\begin_inset Quotes eld
\end_inset

mh-utils.c
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\size small
int main (void)
\end_layout

\begin_layout LyX-Code

\size small
{
\end_layout

\begin_layout LyX-Code

\size small
   DDRB = 1;     // configure PB0 as output
\end_layout

\begin_layout LyX-Code

\size small
   for(;;)
\end_layout

\begin_layout LyX-Code

\size small
   {
\end_layout

\begin_layout LyX-Code

\size small
   PORTB = 1; 
\end_layout

\begin_layout LyX-Code

\size small
   delay_ms(500);
\end_layout

\begin_layout LyX-Code

\size small
   PORTB = 0;
\end_layout

\begin_layout LyX-Code

\size small
   delay_ms(500);
\end_layout

\begin_layout LyX-Code

\size small
   }
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
If everything goes fine, you should see the LED blinking.
 You can remove the delay statements and watch the high frequency pulses
 on PB0 using an oscilloscope.
\end_layout

\begin_layout Section
The LCD Display
\end_layout

\begin_layout Standard
For many applications, it is necessary to have a local display.
 The HD44780 controller, or compatible IC, based displays are widely available.
 They come with a 16 pin connector and the transfer protocol is well documented
 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
For details refer to http://en.wikipedia.org/wiki/Hitachi_HD44780_LCD_controller
\end_layout

\end_inset

.
 The connections between microHOPE and the LCD display are shown in figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:LCD-display.-(a)"

\end_inset

(a).
 Pins 4, 5 and 7 of the LCD display are control lines, connected to PC1,
 PC2 and PC4.
 The ASCII codes are transferred in the 4bit mode, using pins 11 to 14 connected
 to PC4, PC5, PC6 and PC7.
 The file 'mh-lcd.c' contains functions to access the display.
 Most of the examples given below make use of the LCD display.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename pics/lcd-con.png
	width 7cm

\end_inset

 
\begin_inset Graphics
	filename pics/lcd-photo.jpg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
LCD display.
 (a) connections to microHOPE (b) Photograph of 2x16 character display
\begin_inset CommandInset label
LatexCommand label
name "fig:LCD-display.-(a)"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The example program 
\series bold
hello.c
\series default
 listed below demonstrates the usage of the LCD display.
\end_layout

\begin_layout LyX-Code

\size small
#include "mh-lcd.c"
\end_layout

\begin_layout LyX-Code

\size small
int main()
\end_layout

\begin_layout LyX-Code

\size small
{
\end_layout

\begin_layout LyX-Code

\size small
lcd_init();
\end_layout

\begin_layout LyX-Code

\size small
lcd_put_string("Hello World");
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
The file 
\family typewriter
mh-lcd.c
\family default
 provides the following functions :
\end_layout

\begin_layout Itemize
lcd_init() : Initializes the LCD display, must be called once in the beginning
\end_layout

\begin_layout Itemize
lcd_clear() : Clears the display
\end_layout

\begin_layout Itemize
lcd_put_char(char ch) : Outputs a single character to the LCD display
\end_layout

\begin_layout Itemize
lcd_put_string(char* s) : Displays a string to the LCD
\end_layout

\begin_layout Itemize
lcd_put_byte(uint8_t i) : Diplays an 8 bit unsigned integer
\end_layout

\begin_layout Itemize
lcd_put_int(uint16_t i) : Displays a 16 bit unsigned integer
\end_layout

\begin_layout Itemize
lcd_put_long(uint32_t i) : Displays a 32 bit unsigned integer
\end_layout

\begin_layout Section
Analog to Digital Converter
\end_layout

\begin_layout Standard
Most of the I/O PORT pins of Atmega32 has alternate functions.
 PA0 to PA7 can be used as ADC inputs by enabling the built-in ADC.
 All the pins configured as inputs in the DDRA will become ADC inputs, but
 the ones configured as outputs will remain as digital output pins.
 The ADC converts the analog input voltage in to a 10-bit digital value.
 The minimum value represents GND and the maximum value represents the ADC
 reference voltage.
 The reference inputs could be AVCC, an internal 2.56V or a voltage connected
 to the AREF pin.
 The selection is done in software.
 The ADC operation is controlled via the registers ADMUX and ADCSRA.
 The data is read from ADCH and ADCL.
\end_layout

\begin_layout Standard
The include file 'mh-adc.c' provides the following functions:
\end_layout

\begin_layout Enumerate
adc_enable() : Enables the ADC
\end_layout

\begin_layout Enumerate
adc_disable() : Disables the ADC
\end_layout

\begin_layout Enumerate
adc_set_ref(ref) : Select the reference, where ref is REF_EXT is an external
 voltage is applied to the AVREF pin, REF_INT to use the internal 2.56 V
 reference and REF_AVCC to connect the AVCC supply internally to AVREF.
\end_layout

\begin_layout Enumerate
read_adc(ch) : Converts the voltage on channel ch and returns it in a 16
 bit number.
\end_layout

\begin_layout Subsection
Reading an Analog Voltage
\end_layout

\begin_layout Standard
The example program 
\emph on
adc.c
\emph default
 , reads an ADC input and display the result on the LCD.
\end_layout

\begin_layout LyX-Code

\size small
#include "mh-lcd.c"
\end_layout

\begin_layout LyX-Code

\size small
#include "mh-adc.c"
\end_layout

\begin_layout LyX-Code

\size small
main()
\end_layout

\begin_layout LyX-Code

\size small
{
\end_layout

\begin_layout LyX-Code

\size small
uint16_t data;
\end_layout

\begin_layout LyX-Code

\size small
lcd_init();
\end_layout

\begin_layout LyX-Code

\size small
adc_enable();
\end_layout

\begin_layout LyX-Code

\size small
data = read_adc(0);
\end_layout

\begin_layout LyX-Code

\size small
lcd_put_int(data);
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Subsection
Programmig ADC registers
\end_layout

\begin_layout Standard
The operation of the ADC is controlled mainly by the registers ADCSRA and
 ADMUX.
 Setting ADEN will enable the ADC and setting ADSC will start a conversion.
 The bit ADIF is set after a conversion and this bit can be cleared by writing
 a '1' to it.
 The ADSP bits decide the speed of operation of the ADC, by pre-scaling
 the clock input.
 The channel number is selected by the MUX0 to MUX4 bits in the ADMUX rregister.
 The reference input is selected by the REFS0 and REFS1 bits.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/adcsra.png
	width 10cm

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/admux.png
	width 10cm

\end_inset


\end_layout

\begin_layout Standard
The program adc-v2.c, demonstrates the usage of these registers.
\end_layout

\begin_layout LyX-Code
#include <avr/io.h> 
\end_layout

\begin_layout LyX-Code
#include "mh-lcd.c"
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
// convert channel 0, set pre-scaler to 7 
\end_layout

\begin_layout LyX-Code
main()
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
uint16_t data; 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
lcd_init();
\end_layout

\begin_layout LyX-Code
ADCSRA = (1 << ADEN) |  7;      // Enable ADC, set clock pre-scaler
\end_layout

\begin_layout LyX-Code
ADMUX =  (1 << REFS0);		  // AVCC reference, channel 0 	
\end_layout

\begin_layout LyX-Code
ADCSRA |=  (1 <<ADSC);          // Start ADC 
\end_layout

\begin_layout LyX-Code
while ( !(ADCSRA & (1<<ADIF)) ) ;	 // wait for ADC conversion
\end_layout

\begin_layout LyX-Code
data = (ADCH << 8) | ADCL;    // make 10 bit data from ADCL and ADCH 
\end_layout

\begin_layout LyX-Code
lcd_put_int(data);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsection
Reading in a Loop
\end_layout

\begin_layout Standard
The example program 
\series bold
adc-loop.c
\series default
 , reads an ADC input in a loop and display the result on the LCD.
 If the input is left unconnected, the displayed value could be anywhere
 between 0 an 1023.
 Connecting PA0 to 5V will display 1023, the maximum output.
\end_layout

\begin_layout LyX-Code

\size small
#include "mh-lcd.c"
\end_layout

\begin_layout LyX-Code

\size small
#include "mh-adc.c"
\end_layout

\begin_layout LyX-Code

\size small
#include "mh-utils.c"
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\size small
main()
\end_layout

\begin_layout LyX-Code

\size small
{
\end_layout

\begin_layout LyX-Code

\size small
uint16_t data;
\end_layout

\begin_layout LyX-Code

\size small
lcd_init();
\end_layout

\begin_layout LyX-Code

\size small
adc_enable();
\end_layout

\begin_layout LyX-Code
for (;;)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code

\size small
    data = read_adc(0);
\end_layout

\begin_layout LyX-Code
    lcd_clear();
\end_layout

\begin_layout LyX-Code

\size small
    lcd_put_int(data);
\end_layout

\begin_layout LyX-Code
    delay_ms(100);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code

\size small
}
\end_layout

\begin_layout Standard
Modify the code for reading other ADC channels.
\end_layout

\begin_layout Subsection
Temperature Controller
\end_layout

\begin_layout Standard
The program adc-loop.c can be easily modified to make a temperature monitor/contr
oller using the LM35 temperature sensor.
 Connect LM35 output to PA0 , preferrably via a DC amplifier with gain=30.
 If the temperature is 100
\begin_inset Formula $^{0}$
\end_inset

C , LM35 gives 100 millivolts output, that gives 3 volts after amplification,
 and around 613 at the ADC output.
\end_layout

\begin_layout Standard
Drive the relay contact controlling the heater from PB0, via a transistor.
 Insert the following line in the beginning
\end_layout

\begin_layout LyX-Code
DDRB = 1       
\end_layout

\begin_layout Standard
and within the loop:
\end_layout

\begin_layout LyX-Code
if (data > 613)       // switch off heater
\end_layout

\begin_deeper
\begin_layout LyX-Code
PORTB = 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
else if (data < 600)   // switch on heater
\end_layout

\begin_deeper
\begin_layout LyX-Code
PORTB = 1;
\end_layout

\end_deeper
\begin_layout Standard
The heater will be switched OFF when the ADC output is greater than 613.
 It will be switched ON only when the output goes below 600.
 The window of 13 is given to avoid the relay chattering.
\end_layout

\begin_layout Section
Timer/Counters
\end_layout

\begin_layout Standard
ATmega16 has three counter/timer units.
 Two of them are of 8 bit size and one is 16 bit.
 The counter input could be from derived from the internal clock or from
 an external source.
 The output of the counter is compared with setpoint registers and different
 types of actions are taken on compare match.
 The mode of operation of Counter/Timer is programmed by setting the bits
 in the control registers.
 These circuits are useful for time interval measurements and generating
 different kinds of waveforms.
\end_layout

\begin_layout Subsection
8 bit Timer/Counter0
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/TCNT0.png
	lyxscale 50
	width 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
8 bit Timer/Counter0 Schematic
\begin_inset CommandInset label
LatexCommand label
name "fig:8-bit-Timer/Counter0"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A block diagram of Timer/Counter0 is shown in figure
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:8-bit-Timer/Counter0"

\end_inset

.
 The counter TCNT0 gets its input and control signals from the control logic
 circuit.
 The counter output is compared with a Output Compare Register OCR0 and
 a compare match can trigger different types of actions, like generating
 a waveform on OC0 (pin 4 of Atmega32, same as PB3).
 The mode of operation is decided by the register TCCR0, shown below:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/tccr0.png
	width 9cm

\end_inset


\end_layout

\begin_layout Standard
Let us start using Timer/Counter0 with the help of the following functions.
\end_layout

\begin_layout Subsubsection*
sqwave_tc0(csb, ocrval) 
\end_layout

\begin_layout Standard
This function generates a square wave on OC0, whose frequency is decided
 by the clock select bits (csb) and ocrval.
 Example 
\series bold
sqwave-tc0.c
\series default
 listed below demonstrates the usage of this function.
\end_layout

\begin_layout LyX-Code
// example : sqwave-tc0.c
\end_layout

\begin_layout LyX-Code
#include "mh-timer.c"
\end_layout

\begin_layout LyX-Code
csb = 2;       // Clock select bits 
\end_layout

\begin_layout LyX-Code
ocrval = 99;   // Output Compare register vaule
\end_layout

\begin_layout LyX-Code
int main() 
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
sqwave_tc0(csb, ocrval);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
The 8MHz system clock is divided by 8 (csb =2, refer to table below) to
 get a 1MHz input to the counter.
 The OCR0 register is set to 99.
 The mode bits are set such that the when the counter value reaches the
 OCR0, the output is toggled and counter is cleared.
 This will result in the waveform generator output toggles after every 100
 clock cycles, giving a 5kHz sqaurewave on pin OC0 (PB3).
 You may view this on an oscilloscope.
 If you do not have one, connect a loudspeaker with a 100
\begin_inset Formula $\Omega$
\end_inset

 series resistor from PB3 to ground.
 We have used expEYES for viewing and characterizing the waveforms generated
 by microHOPE.
\end_layout

\begin_layout Standard
Changing ocrval to 199 will give output 2.5kHz on the output.
 The output frequency is given by the relation
\begin_inset Formula 
\[
f=\frac{f_{clock}}{2.N.(1+OCR0)}
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $f_{clock}$
\end_inset

 is the system clock and 
\begin_inset Formula $N$
\end_inset

 is the clock division factor, as shown below.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/tc0-clockselect.png
	width 9cm

\end_inset


\end_layout

\begin_layout Subsubsection*
pwm_tc0(csb, ocrval) 
\end_layout

\begin_layout Standard
This function generates a Pulse Width Modulated waveform on OC0, whose frequency
 is decided by the clock select bits (csb) and the duty cycle by the ocrval.
 The output OC0 is cleared when the counter reaches the OCR0 value, the
 counter proceeds upto 255 and then sets OC0.
 The program 
\series bold
pwm-tc0.c
\series default
 generates a 3.9 kHz PWM with 25% dutycycle.
\end_layout

\begin_layout LyX-Code
// example : pwm-tc0.c
\end_layout

\begin_layout LyX-Code
#include "mh-timer.c"
\end_layout

\begin_layout LyX-Code
uint8_t  csb = 2;   // Clock select bits uint8_t  
\end_layout

\begin_layout LyX-Code
ocrval = 63;       // Output Compare register vaule
\end_layout

\begin_layout LyX-Code
int main()
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
  pwm_tc0(csb, ocrval);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
PWM waveforms are often used for generating analog DC voltages, in 0 to
 5 volts range, by filtering it using an RC circuit.
 It is better to set a higher frequency so that the filter RC value could
 be small.
 The frequency can be made 31.25kHz by setting csb=1.
 The DC level is decided by the value of OCR0, ranging from 0 to 255.
 Once you learn howto manipulate the control registers, the same thing can
 be done without calling the library function, as shown below.
\end_layout

\begin_layout LyX-Code
// example : pwm-tc0-v2.c
\end_layout

\begin_layout LyX-Code
#include <avr/io.h>
\end_layout

\begin_layout LyX-Code
uint8_t csb = 1;     // Clock select bits uint8_t 
\end_layout

\begin_layout LyX-Code
ocrval = 254/4;      // Output Compare register vaule
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
int main() 
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
// Set TCCR0 in the Fast PWM mode 
\end_layout

\begin_layout LyX-Code
TCCR0 =(1 << WGM01) | (1 << WGM00) | (1 << COM01) | csb; 
\end_layout

\begin_layout LyX-Code
OCR0 = ocrval; 
\end_layout

\begin_layout LyX-Code
TCNT0 = 0; 
\end_layout

\begin_layout LyX-Code
DDRB |= (1 << PB3); // Set PB3(OC0) as output 
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Connect a 1k resistor and 100uF capacitor in series from PB3 to ground,as
 shown below, and measure the voltage across the capacitor using a voltmeter.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename pics/pwm-rc.png
	height 1cm

\end_inset


\end_layout

\begin_layout Subsection
16 bit Timer/Counter1
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/tc1-block.png
	lyxscale 50
	width 10cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
16 bit Timer/Counter1 schematic
\begin_inset CommandInset label
LatexCommand label
name "fig:16-bit-Timer/Counter1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Timer/Counter1 has more features like two Output Compare Registers,
 Input Capture unit etc., as shown in figure
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:16-bit-Timer/Counter1"

\end_inset

.
 The frequency and duty cycle of the waveforms can be controlled better
 due to the 16 bit size of the counters.
 Some C functions to use the T/C1 are given below.
\end_layout

\begin_layout Subsubsection*
sqwave_tc1(csb, OCRA) 
\end_layout

\begin_layout LyX-Code
// example : sqwave-tc1.c
\end_layout

\begin_layout LyX-Code
#include "mh-timer.c" 
\end_layout

\begin_layout LyX-Code
uint8_t  csb = 2;       // 2 is divide by 8 option, 1MHz clock in 
\end_layout

\begin_layout LyX-Code
uint16_t  ocra = 50000;  // Output Compare register A
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
int main() 
\end_layout

\begin_deeper
\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
sqwave_tc1(csb, ocra);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\end_deeper
\begin_layout Subsubsection*
pwm10_tc1(csb, OCRA) 
\end_layout

\begin_layout Standard
This function generates a PWM waveform with 10bit resolution.
 The value of ocra should be from 0 to 1023 to set the duty cycle.
\end_layout

\begin_layout LyX-Code
// example : pwm-tc1.c
\end_layout

\begin_layout LyX-Code
#include "mh-timer.c"
\end_layout

\begin_layout LyX-Code
uint8_t  csb = 1;        // 1 => 8MHz clock in 
\end_layout

\begin_layout LyX-Code
uint16_t  ocra = 1024/3;  // Duty cycle arounf 33%
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
int main() 
\end_layout

\begin_layout LyX-Code
  { 
\end_layout

\begin_layout LyX-Code
  pwm10_tc1(csb, ocra);
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout Subsection
8 bit Timer/Counter2
\end_layout

\begin_layout Standard
This one is similar to Timer/Counter0.
 
\end_layout

\begin_layout Subsubsection*
sqwave_tc2(uint32_t freq) 
\end_layout

\begin_layout Standard
This function generates a square wave on OC2.
 The clock selction bits and the OCR2 value are calculated.
 It is not possible to set all frequency values using this method.
 The actual frequency set is returned and displayed on the LCD.
\end_layout

\begin_layout LyX-Code
//Example sqwave-tc2.c
\end_layout

\begin_layout LyX-Code
#include "mh-timer.c" 
\end_layout

\begin_layout LyX-Code
#include "mh-lcd.c"
\end_layout

\begin_layout LyX-Code
int main() 
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
uint32_t f;
\end_layout

\begin_layout LyX-Code
lcd_init();
\end_layout

\begin_layout LyX-Code
f = set_sqr_tc2(1500);
\end_layout

\begin_layout LyX-Code
lcd_put_long(f);
\end_layout

\begin_layout LyX-Code
} 
\end_layout

\begin_layout Subsubsection*
PWM by programming the registers
\end_layout

\begin_layout Standard
The example given below demonstrates the usage of T/C2 as a PWM waveform
 generator, by setting the control register bits.
 The duty cycle is set to 25% by setting the OCR2 to one fourth of the maximum.
\end_layout

\begin_layout LyX-Code
// example : pwm-tc2.c
\end_layout

\begin_layout LyX-Code
#include <avr/io.h>
\end_layout

\begin_layout LyX-Code
uint8_t csb = 2;     // Clock select bits uint8_t 
\end_layout

\begin_layout LyX-Code
ocrval = 255/4;      // Output Compare register vaule
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
int main() 
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
// Set TCCR0 in the Fast PWM mode 
\end_layout

\begin_layout LyX-Code
TCCR2 =(1 << WGM21) | (1 << WGM20) | (1 << COM21) | csb; 
\end_layout

\begin_layout LyX-Code
OCR2 = ocrval; 
\end_layout

\begin_layout LyX-Code
TCNT0 = 0; 
\end_layout

\begin_layout LyX-Code
DDRD |= (1 << PD7); // Set PD7(OC2) as output 
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection
More applications of Timer/Counter
\end_layout

\begin_layout Standard
Timer/Counter can be used for timing applications, like measuring the time
 elapsed between two events or counting the number of pulse inputs during
 a specified time interval.
 
\end_layout

\begin_layout Subsubsection*
measure_frequency()
\end_layout

\begin_layout Standard
This function counts the number of pulses received on the external input
 of Timer/Counter1 (PB1) during 500 milliseconds to calculates the frequency
 of the input pulse.
\end_layout

\begin_layout LyX-Code
// Example freq-counter.c
\end_layout

\begin_layout LyX-Code
#include "mh-utils.c" 
\end_layout

\begin_layout LyX-Code
#include "mh-timer.c" 
\end_layout

\begin_layout LyX-Code
#include "mh-lcd.c"
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
int main() 
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
uint32_t f; 
\end_layout

\begin_layout LyX-Code
set_sqr_tc2(1500);    // Set a square wave on TC2 output (PD7)
\end_layout

\begin_layout LyX-Code
lcd_init(); 
\end_layout

\begin_layout LyX-Code
while(1)    
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
   f = measure_freq();
\end_layout

\begin_layout LyX-Code
   lcd_clear();
\end_layout

\begin_layout LyX-Code
   lcd_put_long(f);
\end_layout

\begin_layout LyX-Code
   delay_ms(200);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
return 0;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Connect PD7 to PB1 and upload the program 
\series bold
freq-counter.c
\series default
 to read the frequency on the LCD display.
 You can also connect PB1 to an external pulse source to measure its frequency.
 The maximum frequency that can be measured is limited by the size of the
 counter, that is 63535, means we it can handle upto around 126 kHz.
\end_layout

\begin_layout Subsubsection*
Time Interval Measurement
\end_layout

\begin_layout Standard
The T/C units can be programmed to keep track of time interval between two
 events.
 The program 
\series bold
r2ftime.c
\series default
 measures the rising edge to falling edge time on PB1.
\end_layout

\begin_layout LyX-Code
// Example r2ftime.c
\end_layout

\begin_layout LyX-Code
#include "mh-utils.c"
\end_layout

\begin_layout LyX-Code
#include "mh-timer.c"
\end_layout

\begin_layout LyX-Code
#include "mh-lcd.c"
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
int main()
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
lcd_init();
\end_layout

\begin_layout LyX-Code
set_sqr_tc2(500);    // Test signal on PD7
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
while(1)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
   lcd_clear();
\end_layout

\begin_layout LyX-Code
   lcd_put_long(r2ftime(PB1));
\end_layout

\begin_layout LyX-Code
   delay_ms(100);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
The function r2ftime() uses two other functions, called start_timer() and
 read_timer(), that are explained below.
\end_layout

\begin_layout Itemize
void start_timer() : Start the counter with a 1 MHz clock input.
 An interrupt service routine is activated when the count reached 50000,
 that increments another interger.
\end_layout

\begin_layout Itemize
uint32_t read_timer() : Stops the counter and returns the microseconds elapsed
 after calling start_timer().
 There will be an error of 2 to 3 microseconds, that is due to the overhead
 of the function calls.
\end_layout

\begin_layout Subsubsection
Distance Measurement
\end_layout

\begin_layout Standard
This technique is used for measuring distance using an ultrasound echo module
 HY-SRF05
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://www.robot-electronics.co.uk/htm/srf05tech.htm
\end_layout

\end_inset

, using 
\series bold
ultra-sound-echo.c
\series default
.
 The trigger is connected to PB0 and the echo is connected to PB1.
 The distance is measured by 
\end_layout

\begin_layout LyX-Code
// Example ultra-sound-echo.c
\end_layout

\begin_layout LyX-Code
#include "mh-utils.c"
\end_layout

\begin_layout LyX-Code
#include "mh-timer.c"
\end_layout

\begin_layout LyX-Code
#include "mh-lcd.c"
\end_layout

\begin_layout LyX-Code
int vsby2 = 17;  // velocity of sound in air = 34 mS/cm
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
int main()
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
uint32_t x;
\end_layout

\begin_layout LyX-Code
DDRB |=  (1 << PB0);  // set PB0 as output
\end_layout

\begin_layout LyX-Code
DDRB &= ~(1 << PB1);  // and PB1 as inpt    
\end_layout

\begin_layout LyX-Code
lcd_init();
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
while(1)
\end_layout

\begin_layout LyX-Code
   {
\end_layout

\begin_layout LyX-Code
   PORTB |=  (1 << PB0);   // set PB0 HIGH
\end_layout

\begin_layout LyX-Code
   delay_100us(1);
\end_layout

\begin_layout LyX-Code
   PORTB &=  ~(1 << PB0);  // set PB0 LOW
\end_layout

\begin_layout LyX-Code
   delay_100us(5);         // Wait for a while to avoid false triggering
\end_layout

\begin_layout LyX-Code
   start_timer();    
\end_layout

\begin_layout LyX-Code
   while( (PINB & 2) != 0 ) ;   // Wait for LOW on PB1
\end_layout

\begin_layout LyX-Code
   x = read_timer() + 400;
\end_layout

\begin_layout LyX-Code
   lcd_clear();
\end_layout

\begin_layout LyX-Code
   lcd_put_long(x*vsby2/1000);  // distance in cm
\end_layout

\begin_layout LyX-Code
   delay_ms(500);
\end_layout

\begin_layout LyX-Code
   }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Section
Talking to the PC, via USB
\end_layout

\begin_layout Standard
On the microHOPE board, the Rx/Tx pins of ATmega32 are connected to the
 USB to Serial Converter IC.
 User programs also can use this path to communicate to the PC via the USB
 port.
\end_layout

\begin_layout Standard
The following functions are available for handling the UART
\end_layout

\begin_layout Enumerate
uart_init(baud) : 38400 is the maximum baudrate supported.
 You can use any submultiple of that.
 We use 1 Stop Bit and the parity is Even.
\end_layout

\begin_layout Enumerate
uart_recv_byte() : Waits on the UART receiver for a character and returns
 it
\end_layout

\begin_layout Enumerate
uart_send_byte(c) : Sends one character over the UART transmitter.
\end_layout

\begin_layout Standard
On the PC side, we use a simple Python program to communicate to the micro-contr
oller.
 The USB to Serial interface will appear as a virtual COM port on the PC,
 on GNU/Linux systems it can be accessed as /dev/ttyUSB0.
 You need to install Python interpreter and the python-serial module on
 the PC for this to work.
 These Python programs should be terminated before using microHOPE again
 to upload programs.
\end_layout

\begin_layout Subsection
Send/receive Characters
\end_layout

\begin_layout Standard
The program 
\series bold
echo.c
\series default
 waits for data from the PC, vis the USB to serial converter, increment
 it by one and sends it back.
 The received data is also displayed on the local LCD display.
\end_layout

\begin_layout LyX-Code
#include "mh-lcd.c" 
\end_layout

\begin_layout LyX-Code
#include "mh-uart.c"
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
int main(void) 
\end_layout

\begin_layout LyX-Code
{ 
\end_layout

\begin_layout LyX-Code
uint8_t data;
\end_layout

\begin_layout LyX-Code
lcd_init(); 
\end_layout

\begin_layout LyX-Code
uart_init(38400);
\end_layout

\begin_layout LyX-Code
for(;;)   
\end_layout

\begin_layout LyX-Code
     {
\end_layout

\begin_layout LyX-Code
      data = uart_recv_byte();
\end_layout

\begin_layout LyX-Code
      lcd_put_char(data);
\end_layout

\begin_layout LyX-Code
      uart_send_byte(data);
\end_layout

\begin_layout LyX-Code
     }
\end_layout

\begin_layout LyX-Code
} 
\end_layout

\begin_layout Standard
After uploading this program, open a terminal window, change to the directory
 named microhope and run the python program 
\series bold
echo.py
\series default
 listed below, using the commands:
\end_layout

\begin_layout Standard
$ cd microhope
\end_layout

\begin_layout Standard
$ python echo.py 
\end_layout

\begin_layout LyX-Code
import serial
\end_layout

\begin_layout LyX-Code
fd = serial.Serial('/dev/ttyS0', 38400, stopbits=1, 
\backslash

\end_layout

\begin_layout LyX-Code
    timeout = 1.0)
\end_layout

\begin_layout LyX-Code
while 1:   
\end_layout

\begin_layout LyX-Code
    c = raw_input('Enter the character to send: ')
\end_layout

\begin_layout LyX-Code
    fd.write(c)	   
\end_layout

\begin_layout LyX-Code
    print 'Receiced ', fd.read() 
\end_layout

\begin_layout Standard
We can rewrite echo.c without using the library functions.
 The program 
\series bold
echo-v2.c
\series default
 listed below id functionally identical to echo.c
\end_layout

\begin_layout LyX-Code
#include "mh-lcd.c"
\end_layout

\begin_layout LyX-Code
int main(void)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
  uint8_t data;
\end_layout

\begin_layout LyX-Code
  lcd_init();
\end_layout

\begin_layout LyX-Code
  // set UART to 38400 baudrate, 8 databit, 1 stopbit, No parity
\end_layout

\begin_layout LyX-Code
  UCSRB = (1 << RXEN) | (1 << TXEN);
\end_layout

\begin_layout LyX-Code
  UBRRH = 0;
\end_layout

\begin_layout LyX-Code
  UBRRL = 12;            // At 8MHz (12 =>38400)
\end_layout

\begin_layout LyX-Code
  UCSRC = (1<<URSEL) | (1<<UCSZ1) | (1<< UCSZ0); 
\end_layout

\begin_layout LyX-Code
  for(;;)
\end_layout

\begin_layout LyX-Code
     {
\end_layout

\begin_layout LyX-Code
     while ( !(UCSRA & (1<<RXC)) );  //wait on the receiver
\end_layout

\begin_layout LyX-Code
     data = UDR;                     // read a byte
\end_layout

\begin_layout LyX-Code
     lcd_put_char(data);
\end_layout

\begin_layout LyX-Code
     while ( !(UCSRA & (1<<UDRE)) ); // wait on Data Reg Empty flag
\end_layout

\begin_layout LyX-Code
     UDR = data;
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection
Sending ADC data
\end_layout

\begin_layout Standard
The program 
\series bold
remote-adc.c
\series default
, listed below, on receiving a channel number, in 0 to 7 range, reads the
 corresponding channel and send the data to the PC using the UART, via the
 USB to Serial converter.
 Use the Python program 
\series bold
remote-adc.py
\series default
 on the PC side.
\end_layout

\begin_layout LyX-Code
#include "mh-lcd.c"
\end_layout

\begin_layout LyX-Code
#include "mh-uart.c"
\end_layout

\begin_layout LyX-Code
#include "mh-adc.c"
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
int main(void)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
uint8_t chan, low, hi;
\end_layout

\begin_layout LyX-Code
uint16_t adcval;
\end_layout

\begin_layout LyX-Code
lcd_init();
\end_layout

\begin_layout LyX-Code
uart_init(38400);
\end_layout

\begin_layout LyX-Code
adc_enable();
\end_layout

\begin_layout LyX-Code
for(;;)
\end_layout

\begin_layout LyX-Code
    {
\end_layout

\begin_layout LyX-Code
    data = uart_recv_byte();
\end_layout

\begin_layout LyX-Code
    if (chan <= 7)
\end_layout

\begin_layout LyX-Code
      {
\end_layout

\begin_layout LyX-Code
      adcval = read_adc(chan);
\end_layout

\begin_layout LyX-Code
	  lcd_clear();
\end_layout

\begin_layout LyX-Code
      lcd_put_int(low);
\end_layout

\begin_layout LyX-Code
      low = adcval & 255;
\end_layout

\begin_layout LyX-Code
      hi = adcval >> 8;
\end_layout

\begin_layout LyX-Code
      uart_send_byte(low);      // send LOW byte
\end_layout

\begin_layout LyX-Code
      uart_send_byte(hi);       // send HI byte
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Chapter
Serial Loading of Program memory
\begin_inset CommandInset label
LatexCommand label
name "chap:Serial-Loading-of"

\end_inset


\end_layout

\begin_layout Standard
We are able to load programs to microHOPE through Rx/Tx pins of the UART
 only because of the pre-loaded boot loader program.
 How to program a micro-controller using the In-System Programming (ISP)
 feature is explained below.
 This is implemented using the Serial Peripheral Interface (SPI) interface
 of the micro-controller.
 The SPI consists of three wires, Serial ClocK (SCK), Master-In–Slave-Out
 (MISO) and Master-Out–Slave- In (MOSI).
 All types of memory on the micro-controller can be accessed using the SCK,
 MISO and MOSI pins, while holding the RESET pin LOW.
 These pins, along with ground, are available on the 5 pin header J7 on
 the microHOPE board.
 For details, refer to the circuit schematic shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Circuit-schematic-of"

\end_inset

.
\end_layout

\begin_layout Standard
The SPI pins can be accessed by connecting to the Parallel port of the PC,
 using a cable as shown is figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PC-Parallel-port"

\end_inset

.
 We can also use In-System Programmers that can be connected to the USB
 port of the PC.
 We are using an ISP called the USBASP, that is open hardware.
 
\end_layout

\begin_layout Standard
The microHOPE IDE can upload programs using the USBASP programmer
\end_layout

\begin_layout Standard
\align left
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/minimum_circuit.eps
	width 6cm

\end_inset

 
\begin_inset Graphics
	filename pics/prog_cable.jpg
	lyxscale 50
	width 5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
PC Parallel port cable for Serial loading of program memory.
\begin_inset CommandInset label
LatexCommand label
name "fig:PC-Parallel-port"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/usbasp.png
	width 5cm

\end_inset


\begin_inset Graphics
	filename pics/usbasp-layout.png
	lyxscale 50
	width 6cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
USBASP programmer.(a) block diagram (b) layout
\begin_inset CommandInset label
LatexCommand label
name "fig:USBASP-programmer.(a)-block"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Software
\end_layout

\begin_layout Standard
The program 
\series bold
avrdude
\series default
 can be used for programming the micro-controller by using Parallal port
 or the USBASP programmer.
 The commands to use, as root user, are:
\end_layout

\begin_layout LyX-Code
# avrdude -c dapa -patmega32 -U flash:w:blink.hex
\end_layout

\begin_layout LyX-Code
# avrdude -c usbasp -patmega32 -U flash:w:blink.hex
\end_layout

\begin_layout Standard
The -c option is used for specifying the programmer to be used.
 The commands should be given from a terminal, after changing to the directory
 'microhope', where all the data files are kept.
\end_layout

\begin_layout Subsubsection*
Setting up the Boot Loader
\end_layout

\begin_layout Standard
We can use one of these methods for uploading the bootloader program of
 microHOPE.
 The commands for uploading the hex file and setting the fuses, using the
 parallel port cable, are:
\end_layout

\begin_layout Quote
avrdude -c dapa -patmega32 -U flash:w:ATmegaBOOT_168_atmega32.hex 
\end_layout

\begin_layout Quote
avrdude -c dapa -patmega32 -U lfuse:w:0xef:m -U hfuse:w:0xda:m 
\end_layout

\begin_layout Standard
If you are using USBASP, use:
\end_layout

\begin_layout Quote
avrdude -c usbasp -patmega32 -U flash:w:ATmegaBOOT_168_atmega32.hex 
\end_layout

\begin_layout Quote
avrdude -c usbasp -patmega32 -U lfuse:w:0xef:m -U hfuse:w:0xda:m 
\end_layout

\begin_layout Standard
For more details refer to the microhope section of the website expeyes.in
 
\end_layout

\begin_layout Standard
The circuit schematic of microHOPE is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Circuit-schematic-of"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/circuit-mh.png
	lyxscale 50
	width 12cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Circuit schematic of microHOPE
\begin_inset CommandInset label
LatexCommand label
name "fig:Circuit-schematic-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
